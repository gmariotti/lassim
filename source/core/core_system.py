import pprint

from sortedcontainers import SortedDict, SortedSet

__author__ = "Guido Pio Mariotti"
__copyright__ = "Copyright (C) 2016 Guido Pio Mariotti"
__license__ = "GNU General Public License v3.0"
__version__ = "0.1"


# TODO - consider the possibility of a factory method for creating a new
# CoreSystem starting from the map of reactions. Should it be a static
# method? Or can be exploited the list of tfacts of an existing object?
class CoreSystem:
    def __init__(self, network: SortedDict):
        """
        Network must be something generated by the reading of the file with
        the transcription factor, in the form of a dictionary
        :param network: dictionary with, for each transcription factor,
        the set of transcription factors on which has influence
        """
        self._network = network
        self.tfacts = network.keys()
        self.reactions, self.react_count = self.reactions_from_network()

    def reactions_from_network(self) -> (SortedDict, int):
        """
        The dictionary of reactions returned is reversed in respect to the
        network one. Each transcription factor has the set of transcription
        factors that affect him
        :return: reactions dictionary and number of reactions
        """
        reactions_sorted = SortedDict()
        reactions_count = 0
        for tfact, reactions in self._network.items():
            # in this way, even if a transcription factor is not influenced
            # by anyone, is still have is empty set of reactions
            if tfact not in reactions_sorted:
                reactions_sorted[tfact] = SortedSet()

            for reaction in reactions:
                if reaction not in reactions_sorted:
                    reactions_sorted[reaction] = SortedSet()
                reactions_sorted[reaction].add(tfact)
                reactions_count += 1

        # TODO - should be here or somewhere else??
        # for each empty set, all the transcription factors are added
        for tfact, reactions in reactions_sorted.items():
            if len(reactions) == 0:
                reactions_sorted[tfact] = SortedSet(self.tfacts)
                reactions_count += len(self.tfacts)

        return reactions_sorted, reactions_count

    def from_tfacts_to_ids(self) -> (str, int):
        """
        Maps each transcription factor to an id, starting from 0 until
        len(tfacts) - 1
        :return: (tfact, id)
        """
        for i in range(0, len(self.tfacts)):
            yield self.tfacts[i], i

    def from_ids_to_tfacts(self) -> (str, int):
        """
        Maps each id to its transcription factor. Result is always the same
        because the transcription factors are an ordered set
        :return: (id, tfact)
        """
        for i in range(0, len(self.tfacts)):
            yield i, self.tfacts[i]

    def from_reactions_to_ids(self) -> (str, SortedSet):
        tfacts_ids = {key: value for key, value in self.from_tfacts_to_ids()}
        for tfact, reactions in self.reactions.items():
            reactions_ids = SortedSet([tfacts_ids[tf] for tf in reactions])
            yield tfacts_ids[tfact], reactions_ids

    def get_tfacts_num(self) -> int:
        return len(self.tfacts)

    def print(self):
        print("============================")
        print(self.tfacts)
        print("============================")
        pprint.pprint(self.reactions)
        print("============================")
        for key, value in self.from_tfacts_to_ids():
            print("{} --> {}".format(key, value))
        print("============================")
        for key, value in self.from_reactions_to_ids():
            print("{} --> {}".format(key, value))
        print("============================")
